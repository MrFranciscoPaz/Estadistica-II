knitr::opts_chunk$set(echo = TRUE)
library(MASS)
library(tidyverse)
library(readr)
library(dplyr)
library(knitr)
prostata <- read_csv('datos/prostate.csv') %>% select(lcavol, lpsa, train)
kable(head(prostata),format = 'html')
prostata <- read_csv('datos/prostate.csv') %>% select(lcavol, lpsa, train)
kable(head(prostata),format = 'html')%>%
kable_styling()
prostata <- read_csv('datos/prostate.csv') %>% select(lcavol, lpsa, train)
kable(head(prostata),"html")
prostata <- read_csv('datos/prostate.csv') %>% select(lcavol, lpsa, train)
kable(head(prostata),"html", align = "lccrr")
prostata <- read_csv('datos/prostate.csv') %>% select(lcavol, lpsa, train)
kable(head(prostata), digits = 4")
prostata <- read_csv('datos/prostate.csv') %>% select(lcavol, lpsa, train)
kable(head(prostata), digits = 4)
prostata <- read_csv('datos/prostate.csv') %>% select(lcavol, lpsa, train)
kable(head(prostata), digits = 4, format = hmtl)
knitr::opts_chunk$set(echo = TRUE)
library(MASS)
library(tidyverse)
library(readr)
library(dplyr)
library(knitr)
z_0 <- 5
eta <- 0.4
descenso <- function(n, z_0, eta, h_deriv){
z <- matrix(0,n, length(z_0))
z[1, ] <- z_0
for(i in 1:(n-1)){
z[i+1, ] <- z[i, ] - eta * h_deriv(z[i, ])
}
z
}
grad_calc <- function(x_ent, y_ent){
salida_grad <- function(beta){
f_beta <- as.matrix(cbind(1, x_ent)) %*% beta
e <- y_ent - f_beta
grad_out <- -as.numeric(t(cbind(1, x_ent)) %*% e)
names(grad_out) <- c('Intercept', colnames(x_ent))
grad_out
}
salida_grad
}
rss_calc <- function(datos){
# esta función recibe los datos (x,y) y devuelve
# una función f(betas) que calcula rss
y <- datos$lpsa
x <- datos$lcavol
fun_out <- function(beta){
y_hat <- beta[1] + beta[2]*x
e <- (y - y_hat)
rss <- sum(e^2)
0.5*rss
}
fun_out
}
prostata <- read_csv('datos/prostate.csv') %>% select(lcavol, lpsa, train)
kable(head(prostata), digits = 4)
prostata_entrena <- filter(prostata, train)
ggplot(prostata_entrena, aes(x = lcavol, y = lpsa)) + geom_point() + theme_bw()
rss_prostata <- rss_calc(prostata_entrena)
beta <- c(0,1.5)
rss_prostata(beta)
ggplot(prostata_entrena, aes(x = lcavol, y = lpsa)) + geom_point() +
geom_abline(slope = beta[2], intercept = beta[1], col ='red') + theme_bw()
beta <- c(1,1)
rss_prostata(beta)
ggplot(prostata_entrena, aes(x = lcavol, y = lpsa)) + geom_point() +
geom_abline(slope = beta[2], intercept = beta[1], col ='red') + theme_bw()
grad_prostata <- grad_calc(prostata_entrena[, 1, drop = FALSE], prostata_entrena$lpsa)
grad_prostata(c(0,1))
grad_prostata(c(1,1))
iteraciones <- descenso(100, c(0,0), 0.005, grad_prostata)
iteraciones
iteraciones[100,1]
ggplot(prostata_entrena, aes(x = lcavol, y = lpsa)) + geom_point() +
geom_abline(slope = iteraciones[100,2] , intercept =iteraciones[100,1], col ='red') + theme_bw()
(modelo <- lm(prostata_entrena$lpsa ~ prostata_entrena$lcavol))
summary(modelo)
ggplot(prostata_entrena, aes(x = lcavol, y = lpsa)) + geom_point() +
geom_abline(slope = iteraciones[100,2] , intercept =iteraciones[100,1], col ='red') +
geom_abline(slope = 0.71264, intercept = 1.51630, col ='blue')
+ theme_bw()
ggplot(prostata_entrena, aes(x = lcavol, y = lpsa)) + geom_point() +
geom_abline(slope = iteraciones[100,2] , intercept =iteraciones[100,1], col ='red') +
geom_abline(slope = 0.71264, intercept = 1.51630, col ='blue')+ theme_bw()
ggplot(prostata_entrena, aes(x = lcavol, y = lpsa)) + geom_point() +
geom_abline(slope = iteraciones[100,2] , intercept =iteraciones[100,1], col ='red') +
geom_abline(slope = 0.71264, intercept = 1.51630
, col ='blue',linetype="dashed")
+ theme_bw()
ggplot(prostata_entrena, aes(x = lcavol, y = lpsa)) + geom_point() +
geom_abline(slope = iteraciones[100,2] , intercept =iteraciones[100,1], col ='red') +
geom_abline(slope = 0.71264, intercept = 1.51630
, col ='blue',linetype="dashed")+
theme_bw()
boston <- Boston
kable(head(boston))
?boston
?Boston
knitr::opts_chunk$set(echo = TRUE)
library(MASS)
library(tidyverse)
library(readr)
library(dplyr)
library(knitr)
z_0 <- 5
eta <- 0.4
descenso <- function(n, z_0, eta, h_deriv){
z <- matrix(0,n, length(z_0))
z[1, ] <- z_0
for(i in 1:(n-1)){
z[i+1, ] <- z[i, ] - eta * h_deriv(z[i, ])
}
z
}
grad_calc <- function(x_ent, y_ent){
salida_grad <- function(beta){
f_beta <- as.matrix(cbind(1, x_ent)) %*% beta
e <- y_ent - f_beta
grad_out <- -as.numeric(t(cbind(1, x_ent)) %*% e)
names(grad_out) <- c('Intercept', colnames(x_ent))
grad_out
}
salida_grad
}
rss_calc <- function(datos){
# esta función recibe los datos (x,y) y devuelve
# una función f(betas) que calcula rss
y <- datos$lpsa
x <- datos$lcavol
fun_out <- function(beta){
y_hat <- beta[1] + beta[2]*x
e <- (y - y_hat)
rss <- sum(e^2)
0.5*rss
}
fun_out
}
prostata <- read_csv('datos/prostate.csv') %>% select(lcavol, lpsa, train)
kable(head(prostata), digits = 4)
prostata_entrena <- filter(prostata, train)
ggplot(prostata_entrena, aes(x = lcavol, y = lpsa)) + geom_point() + theme_bw()
rss_prostata <- rss_calc(prostata_entrena)
beta <- c(0,1.5)
rss_prostata(beta)
ggplot(prostata_entrena, aes(x = lcavol, y = lpsa)) + geom_point() +
geom_abline(slope = beta[2], intercept = beta[1], col ='red') + theme_bw()
beta <- c(1,1)
rss_prostata(beta)
ggplot(prostata_entrena, aes(x = lcavol, y = lpsa)) + geom_point() +
geom_abline(slope = beta[2], intercept = beta[1], col ='red') + theme_bw()
grad_prostata <- grad_calc(prostata_entrena[, 1, drop = FALSE], prostata_entrena$lpsa)
grad_prostata(c(0,1))
grad_prostata(c(1,1))
iteraciones <- descenso(100, c(0,0), 0.005, grad_prostata)
iteraciones
iteraciones[100,1]
ggplot(prostata_entrena, aes(x = lcavol, y = lpsa)) + geom_point() +
geom_abline(slope = iteraciones[100,2] , intercept =iteraciones[100,1], col ='red') +
geom_abline(slope = 0.71264, intercept = 1.51630
, col ='blue',linetype="dashed")+
theme_bw()
(modelo <- lm(prostata_entrena$lpsa ~ prostata_entrena$lcavol))
summary(modelo)
cars <- cars
kable(head(cars))
modelo <-  lm(cars$dist ~ cars$speed)
modelo
summary(modelo)
grad_cars<- grad_calc(cars$speed,cars$dist)
iteraciones <- descenso(100,c(0,0),0.005,grad_cars)
grad_cars<- grad_calc(cars$speed,cars$dist)
iteraciones <- descenso(100,c(0,0),0.005,grad_cars)
iteraciones
grad_cars<- grad_calc(cars$speed,cars$dist)
iteraciones <- descenso(100,c(0,0),0.0005,grad_cars)
iteraciones
grad_cars<- grad_calc(cars$speed,cars$dist)
iteraciones <- descenso(100,c(0,0),0.00005,grad_cars)
iteraciones
grad_cars<- grad_calc(cars$speed,cars$dist)
iteraciones <- descenso(1000,c(0,0),0.00005,grad_cars)
iteraciones
grad_cars<- grad_calc(cars$speed,cars$dist)
iteraciones <- descenso(1000,c(0,0),0.005,grad_cars)
iteraciones
grad_cars<- grad_calc(cars$speed,cars$dist)
iteraciones <- descenso(1000,c(0,0),0.0005,grad_cars)
iteraciones
grad_cars<- grad_calc(cars$speed,cars$dist)
iteraciones <- descenso(100000,c(0,0),0.00005,grad_cars)
iteraciones
plot(cars$dist,cars$speed)
knitr::opts_chunk$set(echo = TRUE)
library(MASS)
library(tidyverse)
library(readr)
library(dplyr)
library(knitr)
library(scales)
z_0 <- 5
eta <- 0.4
descenso <- function(n, z_0, eta, h_deriv){
z <- matrix(0,n, length(z_0))
z[1, ] <- z_0
for(i in 1:(n-1)){
z[i+1, ] <- z[i, ] - eta * h_deriv(z[i, ])
}
z
}
grad_calc <- function(x_ent, y_ent){
salida_grad <- function(beta){
f_beta <- as.matrix(cbind(1, x_ent)) %*% beta
e <- y_ent - f_beta
grad_out <- -as.numeric(t(cbind(1, x_ent)) %*% e)
names(grad_out) <- c('Intercept', colnames(x_ent))
grad_out
}
salida_grad
}
rss_calc <- function(datos){
# esta función recibe los datos (x,y) y devuelve
# una función f(betas) que calcula rss
y <- datos$lpsa
x <- datos$lcavol
fun_out <- function(beta){
y_hat <- beta[1] + beta[2]*x
e <- (y - y_hat)
rss <- sum(e^2)
0.5*rss
}
fun_out
}
prostata <- read_csv('datos/prostate.csv') %>% select(lcavol, lpsa, train)
kable(head(prostata), digits = 4)
prostata_entrena <- filter(prostata, train)
ggplot(prostata_entrena, aes(x = lcavol, y = lpsa)) + geom_point() + theme_bw()
rss_prostata <- rss_calc(prostata_entrena)
beta <- c(0,1.5)
rss_prostata(beta)
ggplot(prostata_entrena, aes(x = lcavol, y = lpsa)) + geom_point() +
geom_abline(slope = beta[2], intercept = beta[1], col ='red') + theme_bw()
beta <- c(1,1)
rss_prostata(beta)
ggplot(prostata_entrena, aes(x = lcavol, y = lpsa)) + geom_point() +
geom_abline(slope = beta[2], intercept = beta[1], col ='red') + theme_bw()
grad_prostata <- grad_calc(prostata_entrena[, 1, drop = FALSE], prostata_entrena$lpsa)
grad_prostata(c(0,1))
grad_prostata(c(1,1))
iteraciones <- descenso(100, c(0,0), 0.005, grad_prostata)
iteraciones
iteraciones[100,1]
(modelo <- lm(prostata_entrena$lpsa ~ prostata_entrena$lcavol))
summary(modelo)
ggplot(prostata_entrena, aes(x = lcavol, y = lpsa)) + geom_point() +
geom_abline(slope = iteraciones[100,2] , intercept =iteraciones[100,1], col ='red') +
geom_abline(slope = modelo$coefficients[2], intercept = modelo$coefficients[1]
, col ='blue',linetype="dashed")+
theme_bw()
plot(cars$dist,cars$speed)
cars <- cars
kable(head(cars))
modelo <-  lm(cars$dist ~ cars$speed)
modelo
summary(modelo)
speed <- rescale(cars$speed )
distancia <- rescale(cars$dist)
plot(speed, distancia)
lm(distancia ~ speed)
grad_cars<- grad_calc(speed,distancia)
iteraciones <- descenso(100000,c(0,0),0.005,grad_cars)
tail(iteraciones)
boston <- Boston
kable(head(boston))
pairs(boston)
names(boston )
dim(boston)
pairs(boston[,c(13,14)])
pairs(boston[,c(13,14)])
pairs(boston)
pairs(boston[,c(13,14)])
pairs(boston[,c(6,13,14)])
pairs(boston)
pairs(boston[,c(5,6,8,13,14)])
pairs(boston[,c(5,6,8,13,14)])
pairs(boston[,c(5,6,8,13,14)])
(modelo <- lm(medv ~ rm , data=boston))
summary(modelo)
modelo$fitted.values
plot(modelo$fitted.values, boston$medv)
ggplot(boston, aes(x = medv, y = rm)) + geom_point() +
geom_abline(slope = iteraciones[100,2] , intercept =iteraciones[100,1], col ='red') +
geom_abline(slope = modelo$coefficients[2], intercept = modelo$coefficients[1]
, col ='blue',linetype="dashed")+
theme_bw()f
knitr::opts_chunk$set(echo = TRUE)
library(MASS)
library(tidyverse)
library(readr)
library(dplyr)
library(knitr)
library(scales)
z_0 <- 5
eta <- 0.4
descenso <- function(n, z_0, eta, h_deriv){
z <- matrix(0,n, length(z_0))
z[1, ] <- z_0
for(i in 1:(n-1)){
z[i+1, ] <- z[i, ] - eta * h_deriv(z[i, ])
}
z
}
grad_calc <- function(x_ent, y_ent){
salida_grad <- function(beta){
f_beta <- as.matrix(cbind(1, x_ent)) %*% beta
e <- y_ent - f_beta
grad_out <- -as.numeric(t(cbind(1, x_ent)) %*% e)
names(grad_out) <- c('Intercept', colnames(x_ent))
grad_out
}
salida_grad
}
rss_calc <- function(datos){
# esta función recibe los datos (x,y) y devuelve
# una función f(betas) que calcula rss
y <- datos$lpsa
x <- datos$lcavol
fun_out <- function(beta){
y_hat <- beta[1] + beta[2]*x
e <- (y - y_hat)
rss <- sum(e^2)
0.5*rss
}
fun_out
}
prostata <- read_csv('datos/prostate.csv') %>% select(lcavol, lpsa, train)
kable(head(prostata), digits = 4)
prostata_entrena <- filter(prostata, train)
ggplot(prostata_entrena, aes(x = lcavol, y = lpsa)) + geom_point() + theme_bw()
rss_prostata <- rss_calc(prostata_entrena)
beta <- c(0,1.5)
rss_prostata(beta)
ggplot(prostata_entrena, aes(x = lcavol, y = lpsa)) + geom_point() +
geom_abline(slope = beta[2], intercept = beta[1], col ='red') + theme_bw()
beta <- c(1,1)
rss_prostata(beta)
ggplot(prostata_entrena, aes(x = lcavol, y = lpsa)) + geom_point() +
geom_abline(slope = beta[2], intercept = beta[1], col ='red') + theme_bw()
grad_prostata <- grad_calc(prostata_entrena[, 1, drop = FALSE], prostata_entrena$lpsa)
grad_prostata(c(0,1))
grad_prostata(c(1,1))
iteraciones <- descenso(100, c(0,0), 0.005, grad_prostata)
iteraciones
iteraciones[100,1]
(modelo <- lm(prostata_entrena$lpsa ~ prostata_entrena$lcavol))
summary(modelo)
ggplot(prostata_entrena, aes(x = lcavol, y = lpsa)) + geom_point() +
geom_abline(slope = iteraciones[100,2] , intercept =iteraciones[100,1], col ='red') +
geom_abline(slope = modelo$coefficients[2], intercept = modelo$coefficients[1]
, col ='blue',linetype="dashed")+
theme_bw()
plot(cars$dist,cars$speed)
cars <- cars
kable(head(cars))
modelo <-  lm(cars$dist ~ cars$speed)
modelo
summary(modelo)
speed <- rescale(cars$speed )
distancia <- rescale(cars$dist)
plot(speed, distancia)
lm(distancia ~ speed)
grad_cars<- grad_calc(speed,distancia)
iteraciones <- descenso(100000,c(0,0),0.005,grad_cars)
tail(iteraciones)
boston <- Boston
kable(head(boston))
pairs(boston)
pairs(boston[,c(5,6,8,13,14)])
(modelo <- lm(medv ~ rm , data=boston))
summary(modelo)
ggplot(boston, aes(x = medv, y = rm)) + geom_point() +
geom_abline(slope = modelo$coefficients[2], intercept = modelo$coefficients[1]
, col ='blue',linetype="dashed")+
theme_bw()f
ggplot(boston, aes(x = medv, y = rm)) + geom_point() +
geom_abline(slope = modelo$coefficients[2], intercept = modelo$coefficients[1]
, col ='blue',linetype="dashed")+
theme_bw()
(modelo <- lm(medv ~ rm , data=boston))
summary(modelo)
ggplot(boston, aes(x = medv, y = rm)) + geom_point() +
geom_abline(slope = modelo$coefficients[2], intercept = modelo$coefficients[1]
, col ='blue',linetype="dashed")+
theme_bw()
ggplot(boston, aes(x = rm, y = medv)) + geom_point() +
geom_abline(slope = modelo$coefficients[2], intercept = modelo$coefficients[1]
, col ='blue',linetype="dashed")+
theme_bw()
(modelo <- lm(medv ~ nox + rm + dis + lstat , data=boston))
summary(modelo)
ggplot(boston, aes(x = rm, y = modelo$fitted.values)) + geom_point() +
geom_abline(slope = 1, intercept = 0
, col ='blue',linetype="dashed")+
theme_bw()
ggplot(boston, aes(x = modelo$fitted.values, y = medv)) + geom_point() +
geom_abline(slope = 1, intercept = 0
, col ='blue',linetype="dashed")+
theme_bw()
cor(modelo$fitted.values,medv)
cor(modelo$fitted.values,boston$medv)
cor(modelo$fitted.values,boston$medv)^2
